// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Node.h"
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::mp2;
using namespace std;

class Node {
  public:
    int id;
    int port;
    finger_entry successor;
    finger_entry predecessor;
    vector<finger_entry> finger_table;
    int m;
    int introducerPort;
    int stabilizeInterval;
    int fixInterval;
    int seed;

    Node(int m, int id, int port) {
      int i;
      figer_entry null_finger = {-1, -1};
      this->m = m;
      this->id = id;
      this->port = port;
      predecessor = {-1, -1};
      successor = {-1, -1};
      for (i = 0; i < m; i++)
        finger_table.push_back(null_finger);
      if (id == 0)
        introducerPort = port;
      else 
        introducerPort = -1;
      stabilizeInterval = 10;
      fixInterval = 10;
      seed = 10;
      srand(seed);
    }

    void setIntroducerPort(int introducerPort) {
      this->introducerPort = introducerPort;
    }

    void setStabilizeInterval(int stabilizeInterval) {
      this->stabilizeInterval = stabilizeInterval;
    }

    void setFixInterval(int fixInterval) {
      this->fixInterval = fixInterval;
    }

    void setSeed(int seed) {
      this->seed = seed;
      srand(seed);
    }

    finger_entry find_successor_local(int id) {
      finger_entry n = find_predecessor(id);

      boost::shared_ptr<TSocket> socket(new TSocket("localhost", n.port));
      boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
      boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
      MyServiceClient client(protocol);
      transport->open();

      finger_entry n_successor;
      client.get_successor(n_successor);
      
      transport->close();
      return n_successor;
    }

    finger_entry find_predecessor(int id) {
      finger_entry n = {me->id, me->port};
      int successor = me->successor.id;

      while (!((successor > n && (id > n && id <= successor)) || 
             (n > successor && (id > n || id <= successor)))) {
        boost::shared_ptr<TSocket> socket1(new TSocket("localhost", n.port));
        boost::shared_ptr<TTransport> 
          transport1(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol> protocol1(new TBinaryProtocol(transport));
        MyServiceClient client1(protocol1);
        transport1->open();
        client1.closest_preceding_finger(n, id);
        transport1->close();

        boost::shared_ptr<TSocket> socket2(new TSocket("localhost", n.port));
        boost::shared_ptr<TTransport> 
          transport2(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol> protocol2(new TBinaryProtocol(transport));
        MyServiceClient client2(protocol2);
        transport2->open();
        finger_entry n_successor;
        client2.get_successor(n_successor);
        successor = n_successor.id;
        transport2->close();
      }
    }

    void join(int introducer) {
      predecessor = {-1, -1};

      assert(introducerPort != -1);
      boost::shared_ptr<TSocket> socket(new TSocket("localhost", 
            introducerPort));
      boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
      boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
      MyServiceClient client(protocol);
      transport->open();

      finger_entry successor;
      client.find_successor(successor, id);

      transport->close();     
      cout << "node = <" << id << ">: initial sucessor= <" << successor.id << ">" << endl;
    }

    void stabilize() {
      boost::shared_ptr<TSocket> socket(new TSocket("localhost", 
            successor.port));
      boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
      boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
      MyServiceClient client(protocol);
      transport->open();
      finger_entry x;
      client.get_predecessor(x);
      transport->close();

      if ((id < successor.id && (x > id && x < successor)) ||
          (successor < id && (x > id || x < successor))) {
        successor = x;
      }

      transport->open();
      client.notify(id);
      transport->close();
    }

    void fix_fingers() {
      int i = (rand() % (m-1)) + 1;
      int start = (id + pow(2, i)) % pow(2, m);
      finger_entry new_finger = me->find_successor_local(start);
      if (finger_table[i] != new_finger) {
        finger_table[i] = new_finger;
        cout << "node= <" << id << ">: updated finger entry: i= <" << i+1 << ">, pointer= <" << new.finger.id << ">" << endl;
      }
    }
};

Node *me;

class NodeHandler : virtual public NodeIf {
 public:
  NodeHandler() {
    // Your initialization goes here
  }
  
  void find_successor(finger_entry& _return, const int32_t id) {
    // Your implementation goes here
    printf("find_successor\n");
    finger_entry n = me->find_predecessor(id);

    boost::shared_ptr<TSocket> socket(new TSocket("localhost", n.port));
    boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
    boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
    MyServiceClient client(protocol);
    transport->open();

    client.get_successor(_return);
    
    transport->close();
  }


  void closest_preceding_finger(finger_entry& _return, const int32_t id) {
    // Your implementation goes here
    printf("closest_preceding_finger\n");
    int i;
    for (i = m - 1; i >= 0; i--) {
      int finger_id = me->finger_table[i].id;
      if ((n < id && (finger_id > n && finger_id < id)) ||
          (n > id && (finger_id < id || finger_id > n)))
        _return = me->finger_table[i];
    }
    _return = {me->id, me->port};
  }
  
  void get_successor(finger_entry& _return) {
    // Your implementation goes here
    printf("get_successor\n");
    _return = me->successor;
  }

  void get_predecessor(finger_entry& _return) {
    // Your implementation goes here
    printf("get_predecessor\n");
    _return = me->predecessor;
  }

  void notify(const finger_entry& n) {
    // Your implementation goes here
    printf("notify\n");
    if ((me->predecessor.id = -1) || 
        ((me->predecessor.id < id && (n.id > me->predecessor.id && n.id < id)) ||
         (id < me->predecessor.id && (n.id > me->predecessor.id || n.id < id)))) {
      if (me->predecessor != n) {
        me->predecessor = n;
        cout << "node= <" << me->id << ">: updated predecessor= <" << n.id << ">" << endl;
      }
    }
  }

};

int main(int argc, char **argv) {
  INIT_LOCAL_LOGGER();
  int opt;
  int long_index;

  int m = -1;
  int id = -1;
  int port = -1;
  int introducerPort = -1;
  int stabilizeInterval = -1;
  int fixInterval = -1;
  int seed = -1;
  const char *logconffile = NULL;
  
  struct option long_options[] = {
    /* mandatory args */
    {"m", required_argument, 0, 1000},
    /* id of this node: 0 for introducer */
    {"id", required_argument, 0, 1001},
    /* port THIS node will listen on, at least for the
     * Chord-related API/service
     */
    {"port", required_argument, 0, 1002},
    /* optional args */
    /* if not introducer (id != 0), then this is required: port
     * the introducer is listening on.
     */
    {"introducerPort", required_argument, 0, 1003},
    /* path to the log configuration file */
    {"logConf", required_argument, 0, 1004},
    /* intervals (seconds) for runs of the stabilization and
     * fixfinger algorithms */
    {"stabilizeInterval", required_argument, 0, 1005},
    {"fixInterval", required_argument, 0, 1006},
    {"seed", required_argument, 0, 1007},
    {0, 0, 0, 0},
  };
  
  while ((opt = getopt_long(argc, argv, "", long_options, &long_index)) != -1) {
      switch (opt) {
      case 0:
          if (long_options[long_index].flag != 0) {
              break;
          }
          printf("option %s ", long_options[long_index].name);
          if (optarg) {
              printf("with arg %s\n", optarg);
          }
          printf("\n");
          break;
      case 1000:
          m = strtol(optarg, NULL, 10);
          assert((m >= 5) && (m <= 10));
          break;
      case 1001:
          id = strtol(optarg, NULL, 10);
          assert(id >= 0);
          break;
      case 1002:
          port = strtol(optarg, NULL, 10);
          assert(port > 0);
          break;
      case 1003:
          introducerPort = strtol(optarg, NULL, 10);
          assert(introducerPort > 0);
          break;
      case 1004:
          logconffile = optarg;
          break;
      case 1005:
          stabilizeInterval = strtol(optarg, NULL, 10);
          assert(stabilizeInterval > 0);
          break;
      case 1006:
          fixInterval = strtol(optarg, NULL, 10);
          assert(fixInterval > 0);
          break;
      case 1007:
          seed = strtol(optarg, NULL, 10);
          break;
      default:
          exit(1);
      }
  }

  // configureLogging(logconffile);
  
  me = new Node(m, id, port);
  if (introducerPort != -1) {
    me->setIntroducerPort(introducerPort);
  }
  if (stabilizeInterval != -1) {
    me->setStabilizeInterval(stabilizeInterval);
  }
  if (fixInterval != -1) {
    me->setFixInterval(fixInterval);
  }
  if (seed != -1) {
    me->setSeed(seed);
  }

  shared_ptr<NodeHandler> handler(new NodeHandler());
  shared_ptr<TProcessor> processor(new NodeProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

