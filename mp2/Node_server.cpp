// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Node.h"
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::mp2;
using namespace std;

class Node {
  private:
    int id;
    int port;
    finger_entry successor;
    finger_entry predecessor;
    vector<finger_entry> finger_table;
    int m;
    int introducerPort;
    int stabilizeInterval;
    int fixInterval;
    int seed;
    bool logConf;
    multimap<

  public:
    Node(int id, int port) {
      this->id = id;
      this->port = port;
      predecessor = {-1, -1};
      successor = {-1, -1};
      introducerPort = -1;
      srand(10);
    }

    void setIntroducerPort(int introducerPort) {
      this->introducerPort = introducerPort;
    }

    void setStabilizeInterval(int stabilizeInterval) {
      this->stabilizeInterval = stabilizeInterval;
    }

    void setFixInterval(int fixInterval) {
      this->fixInterval = fixInterval;
    }

    void setSeed(int seed) {
      this->seed = seed;
      srand(seed);
    }

    finger_entry find_successor_local(int id) {
      finger_entry n = find_predecessor(id);

      boost::shared_ptr<TSocket> socket(new TSocket("localhost", n.port));
      boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
      boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
      MyServiceClient client(protocol);
      transport->open();

      finger_entry n_successor;
      client.get_successor(n_successor);
      
      transport->close();
      return n_successor;
    }

    finger_entry find_predecessor(int id) {
      finger_entry n = {me->id, me->port};
      int successor = me->successor.id;

      while (!((successor > n && (id > n && id <= successor)) || 
             (n > successor && (id > n || id <= successor)))) {
        boost::shared_ptr<TSocket> socket1(new TSocket("localhost", n.port));
        boost::shared_ptr<TTransport> 
          transport1(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol> protocol1(new TBinaryProtocol(transport));
        MyServiceClient client1(protocol1);
        transport1->open();
        client1.closest_preceding_finger(n, id);
        transport1->close();

        boost::shared_ptr<TSocket> socket2(new TSocket("localhost", n.port));
        boost::shared_ptr<TTransport> 
          transport2(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol> protocol2(new TBinaryProtocol(transport));
        MyServiceClient client2(protocol2);
        transport2->open();
        finger_entry n_successor;
        client2.get_successor(n_successor);
        successor = n_successor.id;
        transport2->close();
      }
    }

    void join(int introducer) {
      predecessor = {-1, -1};

      assert(introducerPort != -1);
      boost::shared_ptr<TSocket> socket(new TSocket("localhost", 
            introducerPort));
      boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
      boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
      MyServiceClient client(protocol);
      transport->open();

      finger_entry successor;
      client.find_successor(successor, id);

      transport->close();     
    }

    void stabilize() {
      boost::shared_ptr<TSocket> socket(new TSocket("localhost", 
            successor.port));
      boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
      boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
      MyServiceClient client(protocol);
      transport->open();
      finger_entry x;
      client.get_predecessor(x);
      transport->close();

      if ((id < successor.id && (x > id && x < successor)) ||
          (successor < id && (x > id || x < successor))) {
        successor = x;
      }

      transport->open();
      client.notify(id);
      transport->close();
    }

    void fix_fingers() {
      int i = (rand() % (m-1)) + 1;
      int start = (id + pow(2, i)) % pow(2, m);
      finger_table[i] = me->find_successor_local(start);
    }
};

Node *me;

class NodeHandler : virtual public NodeIf {
 public:
  NodeHandler() {
    // Your initialization goes here
  }
  
  void find_successor(finger_entry& _return, const int32_t id) {
    // Your implementation goes here
    printf("find_successor\n");
    finger_entry n = me->find_predecessor(id);

    boost::shared_ptr<TSocket> socket(new TSocket("localhost", n.port));
    boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
    boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
    MyServiceClient client(protocol);
    transport->open();

    client.get_successor(_return);
    
    transport->close();
  }


  void closest_preceding_finger(finger_entry& _return, const int32_t id) {
    // Your implementation goes here
    printf("closest_preceding_finger\n");
    int i;
    for (i = m - 1; i >= 0; i--) {
      int finger_id = me->finger_table[i].id;
      if ((n < id && (finger_id > n && finger_id < id)) ||
          (n > id && (finger_id < id || finger_id > n)))
        _return = me->finger_table[i];
    }
    _return = {me->id, me->port};
  }
  
  void get_successor(finger_entry& _return) {
    // Your implementation goes here
    printf("get_successor\n");
    _return = me->successor;
  }

  void get_predecessor(finger_entry& _return) {
    // Your implementation goes here
    printf("get_predecessor\n");
    _return = me->predecessor;
  }

  void notify(const finger_entry& n) {
    // Your implementation goes here
    printf("notify\n");
    if ((me->predecessor.id = -1) || 
        ((predecessor.id < id && (n.id > predecessor.id && n.id < id)) ||
         (id < predecessor.id && (n.id > predecessor.id || n.id < id))))
      predecessor = n;
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<NodeHandler> handler(new NodeHandler());
  shared_ptr<TProcessor> processor(new NodeProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

