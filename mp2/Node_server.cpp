// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Node.h"
#include <protocol/TBinaryProtocol.h>
#include <server/TSimpleServer.h>
#include <transport/TServerSocket.h>
#include <transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::mp2;
using namespace std;

class Node {
  private:
    int id;
    int port;
    finger_entry successor;
    finger_entry predecessor;
    vector<finger_entry> finger_table;
    int m;
    int introducerPort;
    int stabilizeInterval;
    int fixInterval;
    int seed;
    bool logConf;
    multimap<

  public:
    Node(int id, int port) {
      this->id = id;
      this->port = port;
    }

    void setIntroducerPort(int introducerPort) {
      this->introducerPort = introducerPort;
    }

    void setStabilizeInterval(int stabilizeInterval) {
      this->stabilizeInterval = stabilizeInterval;
    }

    void setFixInterval(int fixInterval) {
      this->fixInterval = fixInterval;
    }

    void setSeed(int seed) {
      this->seed = seed;
    }

    finger_entry find_successor(int id) {
      finger_entry n = find_predecessor(id);

      boost::shared_ptr<TSocket> socket(new TSocket("localhost", n.port));
      boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
      boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
      MyServiceClient client(protocol);
      transport->open();

      finger_entry n_successor;
      client.get_successor(n_successor);
      
      transport->close();
      return n_successor;
    }

    finger_entry find_predecessor(int id) {
      finger_entry n = {me->id, me->port};
      int successor = me->successor.id;

      while (!((successor > n && (id > n && id <= successor)) || 
             (n > successor && (id > n || id <= successor)))) {
        boost::shared_ptr<TSocket> socket1(new TSocket("localhost", n.port));
        boost::shared_ptr<TTransport> 
          transport1(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol> protocol1(new TBinaryProtocol(transport));
        MyServiceClient client1(protocol1);
        transport1->open();
        client1.closest_preceding_finger(n, id);
        transport1->close();

        boost::shared_ptr<TSocket> socket2(new TSocket("localhost", n.port));
        boost::shared_ptr<TTransport> 
          transport2(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol> protocol2(new TBinaryProtocol(transport));
        MyServiceClient client2(protocol2);
        transport2->open();
        finger_entry n_successor;
        client2.get_successor(n_successor);
        successor = n_successor.id;
        transport2->close();
      }
    }

};

Node *me;

class NodeHandler : virtual public NodeIf {
 public:
  NodeHandler() {
    // Your initialization goes here
  }

  void closest_preceding_finger(finger_entry& _return, const int32_t id) {
    // Your implementation goes here
    printf("closest_preceding_finger\n");
    int i;
    for (i = m - 1; i >= 0; i--) {
      int finger_id = me->finger_table[i].id;
      if ((n < id && (finger_id > n && finger_id < id)) ||
          (n > id && (finger_id < id || finger_id > n)))
        _return = me->finger_table[i];
    }
    _return = {me->id, me->port};
  }
  
  void get_successor(finger_entry& _return) {
    // Your implementation goes here
    printf("get_successor\n");
    _return = me->successor;
  }


};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<NodeHandler> handler(new NodeHandler());
  shared_ptr<TProcessor> processor(new NodeProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

